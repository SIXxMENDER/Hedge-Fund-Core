import os
import time
import logging
from enum import Enum
from typing import List, Dict, Optional, Any

import requests
import pandas as pd
import numpy as np

# --- Logging Configuration ---
# Configure a logger to display detailed information about bot operations.
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

# --- Types and Enumerations for Clarity and Security ---

class TradingSignal(Enum):
    """Enumeration for trading signals generated by the analysis."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"

class Position(Enum):
    """Enumeration for the current position state of the bot."""
    NONE = "NONE"
    LONG = "LONG"  # Buy position

class SniperBot:
    """
    A class representing a simulated trading bot (SniperBot).

    This bot uses a simple moving average crossover strategy to identify
    trends and executes simulated orders with risk management (stop-loss).
    """

    def __init__(
        self,
        symbol: str,
        short_period: int = 12,
        long_period: int = 26,
        stop_loss_percentage: float = 0.05,
        data_interval_days: int = 30
    ):
        """
        Initializes the SniperBot.

        Args:
            symbol (str): The asset symbol to trade (e.g., 'BTC-USD').
            short_period (int): Period for the short simple moving average (SMA).
            long_period (int): Period for the long simple moving average (SMA).
            stop_loss_percentage (float): Maximum loss percentage before selling (e.g., 0.05 for 5%).
            data_interval_days (int): Number of days of historical data to obtain.
        """
        if not (0 < stop_loss_percentage < 1):
            raise ValueError("stop_loss_percentage must be between 0 and 1.")

        self.symbol = symbol
        self.short_period = short_period
        self.long_period = long_period
        self.stop_loss_percentage = stop_loss_percentage
        self.data_interval_days = data_interval_days

        # Mapping of symbols to CoinGecko IDs for the API
        self.coingecko_symbol_map: Dict[str, str] = {
            "BTC-USD": "bitcoin",
            "ETH-USD": "ethereum",
            "SOL-USD": "solana"
        }
        if symbol not in self.coingecko_symbol_map:
            raise ValueError(f"Symbol '{symbol}' not supported. Supported: {list(self.coingecko_symbol_map.keys())}")

        # Bot state
        self.position: Position = Position.NONE
        self.entry_price: float = 0.0
        self.order_history: List[Dict[str, Any]] = []

        logging.info(f"SniperBot initialized for {self.symbol} with SMA({self.short_period}, {self.long_period}) and Stop Loss of {self.stop_loss_percentage:.2%}.")

    def _fetch_historical_data(self) -> Optional[pd.DataFrame]:
        """
        Private method to fetch historical price data from the CoinGecko API.

        Returns:
            Optional[pd.DataFrame]: A pandas DataFrame with 'timestamp' and 'price',
                                    or None if an error occurs.
        """
        coingecko_id = self.coingecko_symbol_map[self.symbol]
        url = f"https://api.coingecko.com/api/v3/coins/{coingecko_id}/market_chart"
        params = {
            "vs_currency": "usd",
            "days": str(self.data_interval_days),
            "interval": "daily"
        }

        try:
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()  # Raises an exception for HTTP error codes
            data = response.json()

            if 'prices' not in data or not data['prices']:
                logging.warning("API response does not contain price data.")
                return None

            df = pd.DataFrame(data['prices'], columns=['timestamp', 'price'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            return df

        except requests.exceptions.RequestException as e:
            logging.error(f"Error connecting to CoinGecko API: {e}")
            return None
        except (KeyError, ValueError) as e:
            logging.error(f"Error processing API data: {e}")
            return None

    def analyze_trend(self, historical_data: pd.DataFrame) -> TradingSignal:
        """
        Analyzes market trend using a simple moving average (SMA) crossover.

        A "golden cross" (short SMA > long SMA) is a buy signal.
        A "death cross" (short SMA < long SMA) is a sell signal.

        Args:
            historical_data (pd.DataFrame): DataFrame with historical prices.

        Returns:
            TradingSignal: The generated trading signal (BUY, SELL, HOLD).
        """
        if len(historical_data) < self.long_period:
            logging.warning("Not enough historical data to calculate moving averages.")
            return TradingSignal.HOLD

        # Calculate SMAs
        historical_data['short_sma'] = historical_data['price'].rolling(window=self.short_period).mean()
        historical_data['long_sma'] = historical_data['price'].rolling(window=self.long_period).mean()

        # Get the latest calculated values
        last_short_sma = historical_data['short_sma'].iloc[-1]
        last_long_sma = historical_data['long_sma'].iloc[-1]

        # Get previous values to detect crossover
        prev_short_sma = historical_data['short_sma'].iloc[-2]
        prev_long_sma = historical_data['long_sma'].iloc[-2]

        # Detect golden cross (Golden Cross) - buy signal
        if prev_short_sma <= prev_long_sma and last_short_sma > last_long_sma:
            logging.info("ðŸŸ¢ Golden Cross detected: Short SMA crosses above Long SMA.")
            return TradingSignal.BUY

        # Detect death cross (Death Cross) - sell signal
        if prev_short_sma >= prev_long_sma and last_short_sma < last_long_sma:
            logging.info("ðŸ”´ Death Cross detected: Short SMA crosses below Long SMA.")
            return TradingSignal.SELL

        # No significant crossover
        return TradingSignal.HOLD

    def manage_risk(self, current_price: float) -> bool:
        """
        Checks if stop-loss should be executed based on current position.

        Args:
            current_price (float): The current asset price.

        Returns:
            bool: True if stop-loss should be activated, False otherwise.
        """
        if self.position == Position.LONG and self.entry_price > 0:
            loss_percentage = (self.entry_price - current_price) / self.entry_price
            if loss_percentage >= self.stop_loss_percentage:
                logging.warning(f"â›” Stop-Loss activated: Loss of {loss_percentage:.2%} (limit: {self.stop_loss_percentage:.2%})")
                return True
        return False

    def execute_order(self, order_type: str, price: float) -> None:
        """
        Simulates the execution of a buy or sell order.

        Args:
            order_type (str): 'BUY' or 'SELL'.
            price (float): Price at which the order is executed.
        """
        order = {
            "type": order_type,
            "price": price,
            "timestamp": pd.Timestamp.now()
        }
        self.order_history.append(order)
        logging.info(f"ðŸ“ Order executed: {order_type} at ${price:.2f}")

        if order_type == "BUY":
            self.position = Position.LONG
            self.entry_price = price
        elif order_type == "SELL":
            self.position = Position.NONE
            self.entry_price = 0.0

    def execute_cycle(self) -> None:
        """
        Executes a complete bot cycle: fetches data, analyzes trend,
        manages risk and executes orders if necessary.
        """
        logging.info("ðŸ”„ Starting trading cycle...")

        # Fetch historical data
        data = self._fetch_historical_data()
        if data is None or data.empty:
            logging.error("Could not obtain historical data. Cycle aborted.")
            return

        current_price = data['price'].iloc[-1]
        logging.info(f"ðŸ’° Current price of {self.symbol}: ${current_price:.2f}")

        # Check stop-loss if there's an open position
        if self.manage_risk(current_price):
            self.execute_order("SELL", current_price)
            return

        # Analyze trend
        signal = self.analyze_trend(data)

        # Execute orders based on signal
        if signal == TradingSignal.BUY and self.position == Position.NONE:
            self.execute_order("BUY", current_price)
        elif signal == TradingSignal.SELL and self.position == Position.LONG:
            self.execute_order("SELL", current_price)
        else:
            logging.info("âž¡ï¸ Signal: HOLD current position.")

        logging.info(f"Current position: {self.position.value}\n")

    def show_history(self) -> None:
        """Displays the complete history of executed orders."""
        print("\n" + "="*80)
        print("ORDER HISTORY")
        print("="*80)
        if not self.order_history:
            print("No orders have been executed yet.")
        else:
            for i, order in enumerate(self.order_history, 1):
                print(f"{i}. {order['type']} | Price: ${order['price']:.2f} | Timestamp: {order['timestamp']}")
        print("="*80 + "\n")


def main():
    """Main function to execute the Sentinel System."""
    print("\nðŸŽ¯ Starting Sentinel Execution Bot (Gold Tier)...\n")
    
    # Create bot instance
    bot = SniperBot(
        symbol="BTC-USD",
        short_period=12,
        long_period=26,
        stop_loss_percentage=0.05,  # 5%
        data_interval_days=30
    )
    
    # Execute a trading cycle
    bot.execute_cycle()
    
    # Show history
    bot.show_history()
    
    print("âœ… Sentinel System executed successfully.\n")


if __name__ == "__main__":
    main()
